title: EventBus源码解析
date: 2018-05-31 16:47:33
category: 源码分析
tags: [EventBus,源码]
---
#### 简介
EventBus顾名思义就是事件总线，用于传送事件，是典型的观察者模式。具体使用可以参照[这里]（）。主要逻辑有三大块，一个订阅（感兴趣的事件），一个发送（事件给订阅者），一个是解除订阅。

#### 原理
订阅事件时（register方法）首先获取事件（event）、订阅事件的对象（target object）以及订阅事件的方法（method）。然后以事件类型为key，把订阅事件的对象以及方法包装起来作为value保存。发送事件时（调用post方法），根据事件类型找到对应订阅对象以及方法，反射调用。解除订阅则是从订阅信息中移除该类上所有的订阅方法。

#### 订阅
订阅分为两大部分：第一步，收集订阅信息。第二步，注册事件以及订阅方法、对象。

##### 收集订阅信息

收集订阅信息主要是从注册对象（target object）上搜集订阅方法信息。分为两种方式：一种是运行时通过反射根据注解获取（效率低）；一种是编译时用注解器生成代码获取（效率高）；看下详细代码：

```java
public void register(Object subscriber) {
        Class<?> subscriberClass = subscriber.getClass();
        List<SubscriberMethod> subscriberMethods = 
            //从注册对象（target object）上搜集订阅方法信息
            subscriberMethodFinder.findSubscriberMethods(subscriberClass);
        synchronized (this) {
            for (SubscriberMethod subscriberMethod : subscriberMethods) {
                //逐个订阅
                subscribe(subscriber, subscriberMethod);
            }
        }
    }
```
findSubscriberMethods首先查看缓存，没有缓存则分两种方式获取注册信息：
```java
 List<SubscriberMethod> findSubscriberMethods(Class<?> subscriberClass) {
        List<SubscriberMethod> subscriberMethods = METHOD_CACHE.get(subscriberClass);
        if (subscriberMethods != null) {
            return subscriberMethods;
        }
		//ignoreGeneratedIndex表示忽略使用注解器生成的信息索引，默认是false
        if (ignoreGeneratedIndex) {
            //运行时反射获取
            subscriberMethods = findUsingReflection(subscriberClass);
        } else {
            //根据编译时生成的信息获取 默认使用这种方式
            subscriberMethods = findUsingInfo(subscriberClass);
        }
        if (subscriberMethods.isEmpty()) {
            throw new EventBusException("Subscriber " + subscriberClass
                    + " and its super classes have no public methods with the @Subscribe annotation");
        } else {
            //缓存起来
            METHOD_CACHE.put(subscriberClass, subscriberMethods);
            return subscriberMethods;
        }
    }
```

###### 运行时通过反射根据注解获取
findUsingReflection会遍历当前类以及其所有父类，获取其所有含有Subscribe注解的方法，并构建SubscriberMethod对象存储起来。

```java
private List<SubscriberMethod> findUsingReflection(Class<?> subscriberClass) {
        //从对象池中获取一个对象
        FindState findState = prepareFindState();
        findState.initForSubscriber(subscriberClass);
        while (findState.clazz != null) {
            //查找类上的注解方法信息存储到findstate中
            findUsingReflectionInSingleClass(findState);
            //遍历父类
            findState.moveToSuperclass();
        }
    	//获取订阅方法信息然后释放findstate对象
        return getMethodsAndRelease(findState);
    }

private void findUsingReflectionInSingleClass(FindState findState) {
        Method[] methods;
        ...
        //获取类上所有方法
        for (Method method : methods) {
            int modifiers = method.getModifiers();
            //如果是pulic 且非static abstract修饰的才查找注解
            if ((modifiers & Modifier.PUBLIC) != 0 && (modifiers & MODIFIERS_IGNORE) == 0) {
                Class<?>[] parameterTypes = method.getParameterTypes();
                //eventbus允许订阅方法只含有一个参数
                if (parameterTypes.length == 1) {
                    Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);
                    //如果含有注解
                    if (subscribeAnnotation != null) {
                        Class<?> eventType = parameterTypes[0];
                        //检查是否满足添加的条件  （如果父类和子类都有相同的方法订阅总是添加父类的方法）
                        if (findState.checkAdd(method, eventType)) {
                            ThreadMode threadMode = subscribeAnnotation.threadMode();
                            //根据注解上的信息以及方法信息构造SubscriberMethod对象
                            findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode,
                                    subscribeAnnotation.priority(), subscribeAnnotation.sticky()));
                        }
                    }
                } 
                //抛出不符合条件的异常
                ...
        }
    }
```

###### 编译时用注解处理器生成代码获取

使用注解处理器生成代码，需要先在gradle中添加配置，配置中会传入生成类的类名到eventbus注解处理器中，在处理器中会生成对应类，类中包含了注解方法的相应信息。

注解器的代码这里就不在分析了。详细可以了解一下annotation processor。

设置使用生成代码注解索引
```java
//EventBusTest是在配置中传入的类名
EventBus.builder().addIndex(new EventBusTest()).installDefaultEventBus();
```
EventBusTest编译时会自动生成，其代码如下：
```java
/** This class is generated by EventBus, do not edit. */
public class EventBusTest implements SubscriberInfoIndex {
    private static final Map<Class<?>, SubscriberInfo> SUBSCRIBER_INDEX;

    static {
        SUBSCRIBER_INDEX = new HashMap<Class<?>, SubscriberInfo>();

        //构造SimpleSubscriberInfo对象
        putIndex(new SimpleSubscriberInfo(EventBusFragment.class, true, new SubscriberMethodInfo[] {
            new SubscriberMethodInfo("onEvent", CustomEvent.class, ThreadMode.MAIN),
            new SubscriberMethodInfo("onEvent2", CustomEvent.class, ThreadMode.BACKGROUND),
            new SubscriberMethodInfo("onEvent3", CustomEvent.class, ThreadMode.ASYNC),
            new SubscriberMethodInfo("onEvent4", CustomEvent.class),
        }));

        putIndex(new SimpleSubscriberInfo(BaseEventBusFragment.class, true, new SubscriberMethodInfo[] {
            new SubscriberMethodInfo("onFragmentEvent2", CustomEvent.class, ThreadMode.MAIN),
        }));

        putIndex(new SimpleSubscriberInfo(EventBusFragment2.class, true, new SubscriberMethodInfo[] {
            new SubscriberMethodInfo("onFragmentEvent2", CustomEvent.class, ThreadMode.MAIN),
        }));

    }

    private static void putIndex(SubscriberInfo info) {
        //以订阅者类型为key 保存起来
        SUBSCRIBER_INDEX.put(info.getSubscriberClass(), info);
    }

    //在findUsingInfo中会调用此方法 获取对应的订阅方法信息
    @Override
    public SubscriberInfo getSubscriberInfo(Class<?> subscriberClass) {
        SubscriberInfo info = SUBSCRIBER_INDEX.get(subscriberClass);
        if (info != null) {
            return info;
        } else {
            return null;
        }
    }
}

```

回过头来看下findUsingInfo方法，findUsingInfo和通过反射获取的流程大致相同，只是多加一个有没有使用subscriberInfoIndexes判断，即上面生成的代码类，如果有则直接调用getSubscriberInfo获取，没有则走反射获取流程。
```java
private List<SubscriberMethod> findUsingInfo(Class<?> subscriberClass) {
        FindState findState = prepareFindState();
        findState.initForSubscriber(subscriberClass);
        while (findState.clazz != null) {
            findState.subscriberInfo = getSubscriberInfo(findState);
            //如果有subscriberInfo，表示使用了生成代码
            if (findState.subscriberInfo != null) {
                SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();
                for (SubscriberMethod subscriberMethod : array) {
                    if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) {
                        findState.subscriberMethods.add(subscriberMethod);
                    }
                }
            } else {
                //使用反射
                findUsingReflectionInSingleClass(findState);
            }
            findState.moveToSuperclass();
        }
        return getMethodsAndRelease(findState);
    }


private SubscriberInfo getSubscriberInfo(FindState findState) {
        if (findState.subscriberInfo != null && findState.subscriberInfo.getSuperSubscriberInfo() != null) {
            SubscriberInfo superclassInfo = findState.subscriberInfo.getSuperSubscriberInfo();
            if (findState.clazz == superclassInfo.getSubscriberClass()) {
                return superclassInfo;
            }
        }
    	//判断是否有subscriberInfoIndexes 有则使用了生成的代码
        if (subscriberInfoIndexes != null) {
            for (SubscriberInfoIndex index : subscriberInfoIndexes) {
                //获取信息
                SubscriberInfo info = index.getSubscriberInfo(findState.clazz);
                if (info != null) {
                    return info;
                }
            }
        }
        return null;
    }
```

##### 注册事件

收集完订阅信息后，需要把这些信息注册起来。注册逻辑主要是根据事件的类型把订阅事件对象及方法保存起来，看下subscribe方法：

```java
 // Must be called in synchronized block
    private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
        //事件类型
        Class<?> eventType = subscriberMethod.eventType;
        //subscriber是订阅事件对象。subscriberMethod是订阅事件方法。
        Subscription newSubscription = new Subscription(subscriber, subscriberMethod);
        //缓存
        CopyOnWriteArrayList<Subscription> subscriptions = subscriptionsByEventType.get(eventType);
        
        if (subscriptions == null) {
            subscriptions = new CopyOnWriteArrayList<>();
            subscriptionsByEventType.put(eventType, subscriptions);
        } else {
            //不能重复添加
            if (subscriptions.contains(newSubscription)) {
                throw new EventBusException("Subscriber " + subscriber.getClass() + " already registered to event "
                        + eventType);
            }
        }

        //没有添加过 根据优先级添加
        int size = subscriptions.size();
        for (int i = 0; i <= size; i++) {
            if (i == size || subscriberMethod.priority > subscriptions.get(i).subscriberMethod.priority) {
                subscriptions.add(i, newSubscription);
                break;
            }
        }
        
        //根据注册对象把该对象上注册的事件类型保存起来
        List<Class<?>> subscribedEvents = typesBySubscriber.get(subscriber);
        if (subscribedEvents == null) {
            subscribedEvents = new ArrayList<>();
            typesBySubscriber.put(subscriber, subscribedEvents);
        }
        subscribedEvents.add(eventType);

        //粘性事件处理
        if (subscriberMethod.sticky) {
            ...
        }
    }
```
至此，所有的订阅信息已经都保存起来了。

#### 发送

发送事件时，首先根据事件类型找到对应的注册信息，然后根据不同的线程模式反射调用订阅方法。线程模式有五种，分别是：POSTING 当前线程中调用订阅方法；MAIN 主线程调用；MAIN_ORDERED 主线程中按照顺序调用，BACKGROUND 后台单个线程按顺序调用，ASYNC 后台多个线程调用。用三个线程poster来处理这五种模式分别是AsyncPoster，HandlerPoster，BackgroundPoster。

事件发送从post方法开始：

```java
/** Posts the given event to the event bus. */
 public void post(Object event) {
        PostingThreadState postingState = currentPostingThreadState.get();
        List<Object> eventQueue = postingState.eventQueue;
        eventQueue.add(event);

        if (!postingState.isPosting) {
            postingState.isMainThread = isMainThread();
            postingState.isPosting = true;
            if (postingState.canceled) {
                throw new EventBusException("Internal error. Abort state was not reset");
            }
            try {
                //从当前线程的事件队列取中逐个发送
                while (!eventQueue.isEmpty()) {
                    postSingleEvent(eventQueue.remove(0), postingState);
                }
            } finally {
                postingState.isPosting = false;
                postingState.isMainThread = false;
            }
        }
    }
```
postSingleEvent方法会找到事件包含的所有类型（自身以及父类型和接口类型），然后逐个按类型发送：
```java
private void postSingleEvent(Object event, PostingThreadState postingState) throws Error {
        Class<?> eventClass = event.getClass();
        boolean subscriptionFound = false;
        //是否允许事件继承 默认true 
        //事件继承 即发送事件所包含的所有类型（自身以及父类型和接口类型）
        if (eventInheritance) {
            //找到事件类型上所包含的所有类型
            List<Class<?>> eventTypes = lookupAllEventTypes(eventClass);
            int countTypes = eventTypes.size();
            for (int h = 0; h < countTypes; h++) {
                Class<?> clazz = eventTypes.get(h);
                //逐个按类型发送
                subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);
            }
        } else {
            subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);
        }
        if (!subscriptionFound) {
            if (logNoSubscriberMessages) {
                logger.log(Level.FINE, "No subscribers registered for event " + eventClass);
            }
            if (sendNoSubscriberEvent && eventClass != NoSubscriberEvent.class &&
                    eventClass != SubscriberExceptionEvent.class) {
                post(new NoSubscriberEvent(this, event));
            }
        }
    }
```
postSingleEventForEventType根据事件类型，找到对应订阅信息，逐个发送：

```java
private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class<?> eventClass) {
        CopyOnWriteArrayList<Subscription> subscriptions;
        synchronized (this) {
            //获取订阅信息
            subscriptions = subscriptionsByEventType.get(eventClass);
        }
        if (subscriptions != null && !subscriptions.isEmpty()) {
            for (Subscription subscription : subscriptions) {
                postingState.event = event;
                postingState.subscription = subscription;
                boolean aborted = false;
                try {
                    //逐个发送事件
                    postToSubscription(subscription, event, postingState.isMainThread);
                    aborted = postingState.canceled;
                } finally {
                    postingState.event = null;
                    postingState.subscription = null;
                    postingState.canceled = false;
                }
                if (aborted) {
                    break;
                }
            }
            return true;
        }
        return false;
    }
```
postToSubscription根据不同的线程模式，做不同的处理

```java
private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) {
        switch (subscription.subscriberMethod.threadMode) {
            case POSTING:
                //直接在当前线程处理
                invokeSubscriber(subscription, event);
                break;
            case MAIN:
                if (isMainThread) {
                    invokeSubscriber(subscription, event);
                } else {
                    //main线程调用
                    mainThreadPoster.enqueue(subscription, event);
                }
                break;
            case MAIN_ORDERED:
                if (mainThreadPoster != null) {
                    mainThreadPoster.enqueue(subscription, event);
                } else {
                    // temporary: technically not correct as poster not decoupled from subscriber
                    invokeSubscriber(subscription, event);
                }
                break;
            case BACKGROUND:
                if (isMainThread) {
                    //后台线程处理
                    backgroundPoster.enqueue(subscription, event);
                } else {
                    //直接在当前线程处理
                    invokeSubscriber(subscription, event);
                }
                break;
            case ASYNC:
                //所有都在异步线程中处理
                asyncPoster.enqueue(subscription, event);
                break;
            default:
                throw new IllegalStateException("Unknown thread mode: " + subscription.subscriberMethod.threadMode);
        }
    }
```
##### HanderPoster

HanderPoster负责在主线程上调用方法。其包含一个事件队列，所有的事件都会先入队列，后给主线程发消息，主线程在handler回调中处理队列中消息。如果执行事件过长，eventbus会将后续队列中事件改期，以避免卡顿。

```java
public class HandlerPoster extends Handler implements Poster {

    private final PendingPostQueue queue;
    private final int maxMillisInsideHandleMessage;
    private final EventBus eventBus;
    private boolean handlerActive;

    protected HandlerPoster(EventBus eventBus, Looper looper, int maxMillisInsideHandleMessage) {
        super(looper);
        this.eventBus = eventBus;
        this.maxMillisInsideHandleMessage = maxMillisInsideHandleMessage;
        queue = new PendingPostQueue();
    }

    public void enqueue(Subscription subscription, Object event) {
        //从对象池中获取一个对象
        PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);
        synchronized (this) {
            //入队列
            queue.enqueue(pendingPost);
            if (!handlerActive) {
                handlerActive = true;
                //发送handler消息
                if (!sendMessage(obtainMessage())) {
                    throw new EventBusException("Could not send handler message");
                }
            }
        }
    }

    @Override
    public void handleMessage(Message msg) {
        boolean rescheduled = false;
        try {
            long started = SystemClock.uptimeMillis();
            //一直循环执行队列中事件，如果执行时间过长，则改期
            while (true) {
                PendingPost pendingPost = queue.poll();
                if (pendingPost == null) {
                    synchronized (this) {
                        // Check again, this time in synchronized
                        pendingPost = queue.poll();
                        if (pendingPost == null) {
                            handlerActive = false;
                            return;
                        }
                    }
                }
                eventBus.invokeSubscriber(pendingPost);
                long timeInMethod = SystemClock.uptimeMillis() - started;
                //如果时间超过了maxMillisInsideHandleMessage，结束这次执行，往handler发条消息，下次在执行，避免卡顿
                if (timeInMethod >= maxMillisInsideHandleMessage) {
                    if (!sendMessage(obtainMessage())) {
                        throw new EventBusException("Could not send handler message");
                    }
                    rescheduled = true;
                    return;
                }
            }
        } finally {
            handlerActive = rescheduled;
        }
    }

```
##### BackgroundPoster

BackgroundPoster内部有一个任务队列，通过线程池来执行任务。当队列执行完毕后会阻塞线程1s，在新的任务到来时唤醒线程，以减少线程回收。

```java
final class BackgroundPoster implements Runnable, Poster {

    private final PendingPostQueue queue;
    private final EventBus eventBus;

    private volatile boolean executorRunning;

    BackgroundPoster(EventBus eventBus) {
        this.eventBus = eventBus;
        queue = new PendingPostQueue();
    }

    public void enqueue(Subscription subscription, Object event) {
        PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);
        synchronized (this) {
            //入队列的时候唤醒阻塞的线程
            queue.enqueue(pendingPost);
            if (!executorRunning) {
                executorRunning = true;
                //线程池Executors.newCachedThreadPool()来执行任务
                eventBus.getExecutorService().execute(this);
            }
        }
    }

    @Override
    public void run() {
        try {
            try {
                while (true) {
                    //如果队列空了，线程等待1000ms
                    PendingPost pendingPost = queue.poll(1000);
                    if (pendingPost == null) {
                        synchronized (this) {
                            // Check again, this time in synchronized
                            pendingPost = queue.poll();
                            if (pendingPost == null) {
                                executorRunning = false;
                                return;
                            }
                        }
                    }
                    eventBus.invokeSubscriber(pendingPost);
                }
            } catch (InterruptedException e) {
                eventBus.getLogger().log(Level.WARNING, Thread.currentThread().getName() + " was interruppted", e);
            }
        } finally {
            executorRunning = false;
        }
    }

}
```
##### AsyncPoster

AsyncPoster很简单，每次的任务都交给线程池来处理，注意避免过多的启动新线程。

```java
class AsyncPoster implements Runnable, Poster {

    private final PendingPostQueue queue;
    private final EventBus eventBus;

    AsyncPoster(EventBus eventBus) {
        this.eventBus = eventBus;
        queue = new PendingPostQueue();
    }

    public void enqueue(Subscription subscription, Object event) {
        PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);
        queue.enqueue(pendingPost);
        eventBus.getExecutorService().execute(this);
    }

    @Override
    public void run() {
        PendingPost pendingPost = queue.poll();
        if(pendingPost == null) {
            throw new IllegalStateException("No pending post available");
        }
        eventBus.invokeSubscriber(pendingPost);
    }

}
```
#### 解除订阅

解除订阅，即移除对应的订阅信息，包括typesBySubscriber中的信息和subscriptionsByEventType中的信息

```java
/** Unregisters the given subscriber from all event classes. */
    public synchronized void unregister(Object subscriber) {
        List<Class<?>> subscribedTypes = typesBySubscriber.get(subscriber);
        if (subscribedTypes != null) {
            for (Class<?> eventType : subscribedTypes) {
                unsubscribeByEventType(subscriber, eventType);
            }
            typesBySubscriber.remove(subscriber);
        } else {
            logger.log(Level.WARNING, "Subscriber to unregister was not registered before: " + subscriber.getClass());
        }
    }

/** Only updates subscriptionsByEventType, not typesBySubscriber! Caller must update typesBySubscriber. */
    private void unsubscribeByEventType(Object subscriber, Class<?> eventType) {
        List<Subscription> subscriptions = subscriptionsByEventType.get(eventType);
        if (subscriptions != null) {
            int size = subscriptions.size();
            for (int i = 0; i < size; i++) {
                Subscription subscription = subscriptions.get(i);
                if (subscription.subscriber == subscriber) {
                    subscription.active = false;
                    subscriptions.remove(i);
                    i--;
                    size--;
                }
            }
        }
    }
```
#### 对象池

使用对象池可以避免对象的频繁创建以节省内存使用

```java
final class PendingPost {
    private final static List<PendingPost> pendingPostPool = new ArrayList<PendingPost>();

    Object event;
    Subscription subscription;
    PendingPost next;

    private PendingPost(Object event, Subscription subscription) {
        this.event = event;
        this.subscription = subscription;
    }

    //获取时，取池中最后一个，如果池中没有了则创建一个
    static PendingPost obtainPendingPost(Subscription subscription, Object event) {
        synchronized (pendingPostPool) {
            int size = pendingPostPool.size();
            if (size > 0) {
                PendingPost pendingPost = pendingPostPool.remove(size - 1);
                pendingPost.event = event;
                pendingPost.subscription = subscription;
                pendingPost.next = null;
                return pendingPost;
            }
        }
        return new PendingPost(event, subscription);
    }

    //释放时，放入池中
    static void releasePendingPost(PendingPost pendingPost) {
        pendingPost.event = null;
        pendingPost.subscription = null;
        pendingPost.next = null;
        synchronized (pendingPostPool) {
            // Don't let the pool grow indefinitely
            if (pendingPostPool.size() < 10000) {
                pendingPostPool.add(pendingPost);
            }
        }
    }

}
```

#### 关键点
1. 注解器生成代码替代反射提高效率
2. 改期避免主线程卡顿
3. 线程池使用以及线程阻塞和唤醒减少线程回收
4. 对象池使用避免频繁的对象创建



